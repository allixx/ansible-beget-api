#!/usr/bin/env python

from collections import defaultdict
from collections.abc import Mapping
from contextlib import suppress

from ansible.errors import AnsibleFilterTypeError
from ansible.module_utils.common.collections import is_sequence
from ansible.plugins.filter.core import flatten


class BegetDNSGetToChange:
    """Transforms DNS records data retrieved from Beget API to format consumable by Beget API
    Ironically the API cannot operate on data generated by itself as-is"""

    IGNORE_RECORDS = [
        "DNS_IP",
    ]

    IGNORE_KEYS = {
        "A": [
            "ttl",
        ],
        "AAAA": [
            "ttl",
        ],
        "CAA": [
            "ttl",
        ],
        "CNAME": [
            "ttl",
        ],
        "TXT": [
            "ttl",
        ],
        "MX": [
            "ttl",
        ],
    }

    PROCESS_VALUES = {
        "MX": {
            "exchange": lambda x: x.rstrip("."),
        }
    }

    RENAME_KEYS = {
        "TXT": {
            "txtdata": "value",
        },
        "A": {
            "address": "value",
        },
        "AAAA": {
            "address": "value",
        },
        "CNAME": {
            "cname": "value",
        },
        "MX": {
            "exchange": "value",
            "preference": "priority",
        },
    }

    ADD_VALUES = {
        "A": {
            "priority": 0,
        },
        "AAAA": {
            "priority": 0,
        },
        "DNS": {
            "priority": 0,
        },
        "TXT": {
            "priority": 0,
        },
        "CNAME": {
            "priority": 0,
        },
    }

    def __transform(self, mykey, mydict):
        result = {}

        for key, value in mydict.items():
            with suppress(KeyError):
                if key in self.IGNORE_KEYS[mykey]:
                    continue

            with suppress(KeyError):
                value = self.PROCESS_VALUES[mykey][key](value)

            with suppress(KeyError):
                key = self.RENAME_KEYS[mykey][key]

            result[key] = value

        with suppress(KeyError):
            result |= self.ADD_VALUES[mykey]

        return result

    def process(self, input_dict):
        result = {}

        if not isinstance(input_dict, Mapping):
            raise AnsibleFilterTypeError(
                f"beget_dns_get_to_change requires a dict, got {type(input_dict)} instead."
            )

        for key, value in input_dict.items():
            if not is_sequence(value):
                raise AnsibleFilterTypeError(
                    f"beget_dns_get_to_change (2) must be list, got {type(value)} instead."
                )

            if key in self.IGNORE_RECORDS:
                continue

            for record in value:
                if not isinstance(record, Mapping):
                    raise AnsibleFilterTypeError(
                        f"beget_dns_get_to_change (3) must be a dict, got {type(record)} instead."
                    )

                if key not in result:
                    result[key] = []
                result[key] += [self.__transform(key, record)]

        return result


def private_dns_to_beget(subdomains, subdomain):
    """Converts private DNS records data to form consumable by Beget API"""

    result = defaultdict(list)

    if not isinstance(subdomains, list):
        raise AnsibleFilterTypeError(
            f"dns_to_beget requires a list, got {type(subdomains)} instead."
        )

    for subdomain in [
        s
        for s in subdomains
        if s.keys() & ["subdomain", "records"] and s["subdomain"] == subdomain
    ]:
        for record in subdomain["records"]:
            rec_type = record["type"]
            rec_value = flatten([record["value"]])

            for v in sorted(rec_value):
                match rec_type:
                    case "A" | "AAAA" | "TXT" | "CNAME":
                        result[rec_type] += [{"value": v, "priority": 0}]

                    case "MX":
                        priority, value = v.split()

                        result[rec_type] += [
                            {
                                "value": value.rstrip("."),
                                "priority": int(priority),
                            }
                        ]

                    case "CAA":
                        flags, tag, value = v.split()

                        result[rec_type] += [
                            {
                                "flags": int(flags),
                                "tag": tag,
                                "value": value.rstrip(".").replace('"', ""),
                            }
                        ]

                    case "NS":
                        result["DNS"] += [{"priority": 0, "value": v.rstrip(".")}]

    return result


class FilterModule:
    def filters(self):
        return {
            # convert Beget API dns/getData results to dns/changeRecords compatible format
            "beget_dns_get_to_change": lambda input_dict: BegetDNSGetToChange().process(
                input_dict
            ),
            # convert private dns records structure to Beget API dns/changeRecords compatible format
            "private_dns_to_beget": private_dns_to_beget,
        }
